#################
Language Support
#################

The |project| program logic is aimed to be a formalization of pragmatic C++. Its feature set is guided by the requirements of low-level program verification and also some pragmatic considerations.

Limitations |project|
======================

|project| does not cover the full feature set of C++. Some features that are explicitly **not supported** are:

* Assumes well-typed programs. The |project| program logic *assumes* that the abstract syntax tree is well-typed and uses this assumption to avoid performing type checking within the semantics.
* |project| is based on the Clang frontend IR. We believe that this is a reasonable proxy for source-level C++.
* Exceptions. In addition to not supporting `throw` and `try`, |project| additionally assumes that function calls do not throw exceptions.
* Weak memory accesses. |project| currently requires that all atomic accesses are sequentially consistent [#weak-mem]_.
* Floating point values and operations
* `virtual` inheritence.
* `template` code can only be reasoned about *after* for a particular instantiation.
* `new[]` and `delete[]` (i.e. array forms of `new` and `delete`)
* Translation unit initialization (i.e. initialization of globals)
* Member pointers (and associated operators, i.e. `.*` and `->*`)
* Member functions, constructors, and destructors are modeled by translating them to functions. This is unsound but requires `reinterpret_cast` to exploit.
* Order of evaluation for function calls follows pre-C++ 17 semantics where argument evaluation can be arbitrarily interleaved.
* Labeled statements and `goto` are not supported.
* `switch` statements have restricted semantics when mixed with control flow.
* The semantics currently ignores `const` and `volatile` qualifiers. We believe it is tractable to give a semantic interpretation of `const`, but it is not clear whether this is sound with respect to C++'s semantics.
* We rely on the semantics of defaulted functions (e.g. default constructors, assignment operators, etc) generated by Clang. If your compiler generates different code (but still semantically correct code), this may invalidate your proof. We recommend using Clang *with exactly the same build parameters as those used in your build* for the best compatibility.
* Transparent replacement is not currently supported.
* Bitfields
* `[packed]` data structures.

Deviations from the Standard
=============================

In certain instances, |project|'s semantics deviates from the C++ standard.

* Our semantics do not currently permit "pointer zapping". See ???Section???
* Function call semantics are do not currently (precisely) follow the standard. We believe that this encoding is sound but are currently working on an approach that more closely tracks teh standard text.

Extensions to the Standard
===========================

|project| also extends the C++ standard in limited ways to make low-level program verification possible.
For example, interoperation with assembly, sharing data across address spaces, etc.
We believe that our extensions are conservative and characterize the way that low-level programmers rely on compilers to work.

.. [#weak-mem] We plan to support weak memory C++ in the future based on other work in Iris.
